# zerobuilder for value types

### Why?

Immutable types, also known as values, are quite popular nowadays.
Their constructors tend to have a lot of arguments, which can lead to code that's hard to read.

Replacing the constructor with a classic builder pattern may improve things, but it comes at a price:

* Creating the builder class is too much work, and it has to be kept in sync.
* Even worse, the builder makes it possible to "forget" a constructor argument. 
  This is especially a problem when existing code still compiles after an argument is added to the constructor.

Zerobuilder takes care of the boilerplate by generating two different variants of the builder pattern:

* A `Builder` to create new instance. 
  In this variant of the builder pattern, it is impossible to omit a constructor argument.
  This is generated by default, unless `@Goal(builder = false)`.
* A classical-builder style `Updater` to make modified shallow copies. 
  This is only generated if `@Goal(toBuilder = true)`.

### How?

Unlike `auto-value` for instance, zerobuilder does not extend abstract classes.
Instead, it generates one standalone "utility" class per `@Builders` annotation.

A valid example:

````java
@Builders(recycle = true)
final class Message {

  final String sender;
  final String body;
  final String recipient;

  @Goal(toBuilder = true)
  Message(String sender, String body, String recipient) {
    this.sender = sender;
    this.body = body;
    this.recipient = recipient;
  }
}

````

In order for the `toBuilder = true` option to make sense,
there has to exist one corresponding _projection_, i.e. a getter or instance field, for each goal parameter.
This is the case in `Message.java`.

The following structure will be generated:

````java
@Generated final class MessageBuilders {

  static MessageBuilder.Sender messageBuilder() { ... }
  static MessageUpdater messageToBuilder(Message message) { ... }

  static final class MessageUpdater {
    MessageUpdater sender(String sender) { ... }
    MessageUpdater body(String body) { ... }
    MessageUpdater recipient(String recipient) { ... }
    Message build() { ... }
  }
  
  static final class MessageBuilder {
    interface Sender { Body sender(String sender); }
    interface Body { Recipient body(String body); }
    interface Recipient { Message recipient(String recipient); }
  }
}
````

If you clone this project and do a `mvn install`, you will find the complete source code of `MessageBuilders.java`
in the `examples/basic/target/generated-sources/annotations` folder.

The `messageBuilder` method returns the first step of a chain of interfaces, which ends in `Message`:

![steps](https://raw.githubusercontent.com/h908714124/zerobuilder/a24575a7255178c4cac0e61b12bb1644d9f39443/dot/graph.png "steps diagram")

### Order of steps

Unlike the methods of `MessageUpdater`, the steps defined in `MessageBuilder` have a fixed order.
By default, they are in the original order of the goal arguments.

If for some reason you would like to call them in a different order, you have some options:

* Change the order of the goal arguments. 
  It is possible to have multiple versions of the same factory method or constructor, with different argument order.
  The `@Goal(name = ...)` attribute can resolve the potential goal name conflict.
* Give the steps an order that is different from the order of arguments, by using `@Step`.
  See [Spaghetti.java](../master/examples/basic/src/main/java/net/zerobuilder/examples/values/Spaghetti.java).

### Factory methods

In addition to constructors, the `@Goal` annotation can appear on methods, even non-static ones. 
Have a look at the [MessageFactory](../master/examples/basic/src/main/java/net/zerobuilder/examples/values/MessageFactory.java) example,
to see what this can be used for.

### Other frameworks

Zerobuilder is flexible enough to build the classes that are generated by other frameworks:

* [auto-value](https://github.com/google/auto/tree/master/value), 
  see [Bob.java](../master/examples/autovalue/src/main/java/net/zerobuilder/examples/autovalue/Bob.java) 
* [derive4j](https://github.com/derive4j/derive4j),
  see [Request.java](../master/examples/derive4j/src/main/java/net/zerobuilder/examples/derive4j/Request.java)

### Null checking

Null checking is enabled by adding a `@Step` annotation	to a goal parameter:

````java
@Goal
public MyBean(@Step(nonNull = true) String name) {
  this.name = name;
}
````

It is also possible to enable null checking for all non-primitive properties at once,
by using the goal level `nonNull` option:

````java
@Goal(nonNull = true)
public MyBean(String name) {
  this.name = name;
}
````

### Empty collections

In java, specifying an <em>empty</em> collection is more work than it should be:

````java
  myObject.callMethod(Collections.<String>emptyList());
````

Because of a restriction in the java type system,
the explicit type argument `<String>` is needed.

For parameters of type `java.util.List` and `java.util.Set`, 
zerobuilder adds `emptyFoo()` convenience methods in all generated builders.
The ugly generics are still there, but hidden in the generated code.

Check out the example projects, or have a look at 
[EmptyListConvenience.java](../master/examples/basic/src/main/java/net/zerobuilder/examples/values/EmptyListConvenience.java) 
and its companion unit test.
