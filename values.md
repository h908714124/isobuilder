# A flexible builder scheme

This project has two different use cases:

* Create and update immutable value objects. 
  See the [documentation for values](values.md).
* Make it easier to create mutable Java Beans and to treat them as if they were immutable, 
  so that they can be used with confidence as data in Java 8 streams.
  See the [documentation for beans](beans.md).

### A closer look

A "Builders" class is generated by adding a `@Builders` annotation and one or more `@Goal` annotations.
Like [this](../master/examples/basic/src/main/java/net/zerobuilder/examples/basic/Message.java):

````java
@Builders(recycle = true)
final class Message {

  final String sender;
  final String body;
  final String recipient;
  final String subject;

  @Goal(toBuilder = true)
  Message(String sender, String body, String recipient, String subject) {
    this.sender = sender;
    this.body = body;
    this.recipient = recipient;
    this.subject = subject;
  }
}

````

This class is valid input for the annotation processor:

* The `recycle = true` says that builder instances should be stored in a `ThreadLocal` and reused. 
  If `ThreadLocal` fields are permissible in your project, this option may be used to reduce overhead.
* In order for `toBuilder = true` to make sense, there has to exist one corresponding "getter" or instance field, for each parameter.
  This is the case in `Message.java`.

The following structure will be generated (some implementation details left out):

````java
@Generated final class MessageBuilders {

  static MessageBuilder.Sender messageBuilder() { ... }
  static MessageUpdater messageToBuilder(Message message) { ... }

  static final class MessageUpdater {
    MessageUpdater sender(String sender) { ... }
    MessageUpdater body(String body) { ... }
    MessageUpdater recipient(String recipient) { ... }
    MessageUpdater subject(String subject) { ... }
    Message build() { ... }
  }
  
  static final class MessageBuilder {
    interface Sender { Body sender(String sender); }
    interface Body { Recipient body(String body); }
    interface Recipient { Subject recipient(String recipient); }
    interface Subject { Message subject(String subject); }
  }
}
````

If you clone this project and do a `mvn install`, you will find the complete source code of `MessageBuilders.java`
in the `examples/basic/target/generated-sources/annotations` folder.

Let's take a closer look at the generated code:

* The `messageBuilder` and `messageToBuilder` methods return different things.
* There is a `MessageUpdater` class, which looks like the familiar builder pattern.
  Each method can be called `0..n` times, and there is an extra `build()` method that returns `Message`.
* For each of the four goal parameters, there is one corresponding "step" interface: `Sender`, `Body`, `Recipient` and `Subject`.
* Each step interface has a single method.
  None of these methods returns the same step. It is a linear chain that leads to the goal type `Message`.

### Fixed order of steps

Just like the arguments of a method or constructor, the goal "steps" have a fixed order.
If for some reason you would like to call them in a different order, you still have some options:

* Change the order of arguments. 
  It is possible to have multiple versions of the same factory method or constructor, with different argument order.
  The `@Goal(name = ...)` attribute can resolve the potential goal name conflict.
* Give the steps an order that is different from the order of arguments or setters, by using `@Step`.
  See examples [Employee.java](../master/examples/basic/src/main/java/net/zerobuilder/examples/beans/Employee.java) and 
  [Spaghetti.java](../master/examples/basic/src/main/java/net/zerobuilder/examples/basic/Spaghetti.java).

### Factory methods

In addition to constructors, the `@Goal` annotation can appear on methods, even non-static ones. 
Have a look at the [MessageFactory](../master/examples/basic/src/main/java/net/zerobuilder/examples/basic/MessageFactory.java) example,
to see what this can be used for.

### Other frameworks

Zerobuilder is flexible enough to build the classes that are generated by other frameworks:

* [auto-value](https://github.com/google/auto/tree/master/value), 
  see [Bob.java](../master/examples/autovalue/src/main/java/net/zerobuilder/examples/autovalue/Bob.java) 
* [derive4j](https://github.com/derive4j/derive4j),
  see [Request.java](../master/examples/derive4j/src/main/java/net/zerobuilder/examples/derive4j/Request.java)
* legacy [JavaBeans](https://en.wikipedia.org/wiki/JavaBean),
  such as generated by [Apache CXF](https://cxf.apache.org/cxf-xjc-plugin.html)

### A note about JavaBeans

Putting the `@Goal` annotation on a 
[field](../master/examples/basic/src/main/java/net/zerobuilder/examples/basic/Beans.java) or on a 
[type](../master/examples/basic/src/main/java/net/zerobuilder/examples/basic/Bean.java) will create "wrapping" 
builders for standard JavaBeans.

The ancient JavaBeans standard cannot be avoided in certain environments, due to framework constraints. 
For example, [JAXB](https://jaxb.java.net/) and 
[JPA](https://en.wikipedia.org/wiki/Java_Persistence_API) require the bean standard.

By wrapping the beans, zerobuilder makes the following tasks easier:

* To create new beans, by ensuring that each setter is invoked exactly once.
* To "update" beans as if they were immutable, by making shallow copies via `toBuilder`.

By treating beans as immutable, they become usable as data in 
[Java 8 Streams](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html).

### Use it in your project

This is a standard Java 7 annotation processor. No compiler plugin or special IDE is needed. 
However, maven compiler plugin version `3.5.1` or greater is recommended.

Your IDE may need some initial help, to recognize that `target/generated-sources/annotations` 
now contains generated sources.

To consumers of your project, the annotated classes, as well as the generated code, 
will appear as normal classes.
The annotations `@Builders`, `@Goal` and possibly `@Step` will never be present in your `.class` files,
so no transitive dependency on zerobuilder arises.

The maven coordinates:

````xml
<dependency>
    <groupId>com.github.h908714124</groupId>
    <artifactId>zerobuilder</artifactId>
    <version>1.301</version>
    <scope>provided</scope>
</dependency>
````
