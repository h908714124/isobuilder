## zerobuilder for value types

### Why?

Immutable types, also known as values, are gaining in popularity.
Their constructors tend to have a lot of arguments, which can lead to code that's hard to read.

Replacing the constructor with a classic builder pattern improves things, but it comes at a price:

* Creating and maintaining the builder class involves lots of boilerplate and repetition.
* It is now possible to "forget" a constructor argument. 
  This is especially a problem when existing code still compiles after the constructor gets an extra argument.

Zerobuilder generates the builder pattern for you, so there's no boilerplate,
and the generated code is updated instantly when the constructor changes.

Moreover, a slightly more elaborate variant of the builder pattern is generated,
which makes it a compile error to not specify one of the constructor arguments.

### How?

Add a `@Builders` annotation to the class, and a `@Goal` 
annotations to one or more constructors (or static methods):

````java
@Builders(recycle = true)
final class Message {

  final String sender;
  final String body;
  final String recipient;
  final String subject;

  @Goal(toBuilder = true)
  Message(String sender, String body, String recipient, String subject) {
    this.sender = sender;
    this.body = body;
    this.recipient = recipient;
    this.subject = subject;
  }
}

````

In order for the `toBuilder = true` option to make sense,
there has to exist one corresponding _projection_, i.e. a getter or instance field, for each goal parameter.
This is the case in `Message.java`.

The following structure will be generated (some implementation details left out):

````java
@Generated final class MessageBuilders {

  static MessageBuilder.Sender messageBuilder() { ... }
  static MessageUpdater messageToBuilder(Message message) { ... }

  static final class MessageUpdater {
    MessageUpdater sender(String sender) { ... }
    MessageUpdater body(String body) { ... }
    MessageUpdater recipient(String recipient) { ... }
    MessageUpdater subject(String subject) { ... }
    Message build() { ... }
  }
  
  static final class MessageBuilder {
    interface Sender { Body sender(String sender); }
    interface Body { Recipient body(String body); }
    interface Recipient { Subject recipient(String recipient); }
    interface Subject { Message subject(String subject); }
  }
}
````

If you clone this project and do a `mvn install`, you will find the complete source code of `MessageBuilders.java`
in the `examples/basic/target/generated-sources/annotations` folder.

Let's take a closer look at the generated code:

* The `messageBuilder` and `messageToBuilder` methods return different things.
* There is a `MessageUpdater` class, which looks like the familiar builder pattern.
  Each method can be called `0..n` times, and there is an extra `build()` method that returns `Message`.
* For each of the four goal parameters, there is one corresponding "step" interface: `Sender`, `Body`, `Recipient` and `Subject`.
* Each step interface has a single method.
  None of these methods returns the same step. It is a linear chain that leads to the goal type `Message`.

### Fixed order of steps

Just like the arguments of a method or constructor, the goal "steps" have a fixed order.
By default, they are in the original order of the goal arguments.

If for some reason you would like to call them in a different order, you have some options:

* Change the order of the goal arguments. 
  It is possible to have multiple versions of the same factory method or constructor, with different argument order.
  The `@Goal(name = ...)` attribute can resolve the potential goal name conflict.
* Give the steps an order that is different from the order of arguments, by using `@Step`.
  See [Spaghetti.java](../master/examples/basic/src/main/java/net/zerobuilder/examples/basic/Spaghetti.java).

### Factory methods

In addition to constructors, the `@Goal` annotation can appear on methods, even non-static ones. 
Have a look at the [MessageFactory](../master/examples/basic/src/main/java/net/zerobuilder/examples/basic/MessageFactory.java) example,
to see what this can be used for.

### Other frameworks

Zerobuilder is flexible enough to build the classes that are generated by other frameworks:

* [auto-value](https://github.com/google/auto/tree/master/value), 
  see [Bob.java](../master/examples/autovalue/src/main/java/net/zerobuilder/examples/autovalue/Bob.java) 
* [derive4j](https://github.com/derive4j/derive4j),
  see [Request.java](../master/examples/derive4j/src/main/java/net/zerobuilder/examples/derive4j/Request.java)
