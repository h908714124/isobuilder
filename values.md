# zerobuilder for value types

### Motivation

Immutable types, also known as values, are quite popular nowadays.
Their constructors tend to have a lot of arguments, which can lead to code that's hard to read.

Replacing the constructor with a classic builder pattern may improve things, but it comes at a price:

* Creating the builder class is too much work, and it has to be kept in sync.
* Even worse, the builder makes it possible to "forget" a constructor argument. 
  This is especially a problem when existing code still compiles after an argument is added to the constructor.

Zerobuilder takes care of the boilerplate by generating two different variants of the builder pattern:

* A `Builder` to create new instance. 
  In this [variant of the builder pattern][1], it is impossible to omit a constructor argument.
* A classical-builder style `Updater` to make modified shallow copies. 

[1]: http://blog.crisp.se/2013/10/09/perlundholm/another-builder-pattern-for-java

### Builder

Start by adding the `@Builder` annotation to a constructor:

````java
final class Message {

  final String sender;
  final String body;
  final String recipient;

  @Builder
  Message(String sender, String body, String recipient) {
    this.sender = sender;
    this.body = body;
    this.recipient = recipient;
  }
}

````

The following class will be generated:

````java
@Generated final class MessageBuilders {

  static MessageBuilder.Sender messageBuilder() { ... }

  static final class MessageBuilder {
    interface Sender { Body sender(String sender); }
    interface Body { Recipient body(String body); }
    interface Recipient { Message recipient(String recipient); }
  }
}
````

The `messageBuilder` method returns `MessageBuilder.Sender`, the first step of a linear
chain towards the constructor goal:

![steps](https://raw.githubusercontent.com/h908714124/zerobuilder/68729a2ecdd44a60be40498eef1abc3b378fb524/dot/graph.png "steps diagram")

### Changing step order

By default, these steps are in the original order of the goal arguments.
If for some reason you would like to call them in a different order, you can use the `@Step` annotation:

````java
  @Builder
  Message(@Step(1) String sender, 
          @Step(2) String body, 
          @Step(0) String recipient) {
    this.sender = sender;
    this.body = body;
    this.recipient = recipient;
  }

````

### Updater

This time, we use a different annotation on the constructor:

````java
final class Message {

  final String sender;
  final String body;
  final String recipient;

  @Updater
  Message(String sender, String body, String recipient) {
    this.sender = sender;
    this.body = body;
    this.recipient = recipient;
  }
}

````

In order for the `@Updater` annotation to work,
there has to exist one corresponding _projection_
for each goal parameter.
This is the case in `Message.java`.

The following class will be generated:

````java
@Generated final class MessageBuilders {

  static MessageUpdater messageUpdater(Message message) { ... }

  static final class MessageUpdater {
    MessageUpdater sender(String sender) { ... }
    MessageUpdater body(String body) { ... }
    MessageUpdater recipient(String recipient) { ... }
    Message done() { ... }
  }
}
````

### What's a projection?

This can either be a non-private field or a non-private, non-static method,
of the same name and type as one of the parameters. Inherited methods are considered.

The following are valid projections for the `sender` parameter above:

1. A field `sender` of type String
2. A method `String sender()`
3. A method `String getSender()`

### Recycling

The builder pattern can be made more efficient by adding a `@Recycle` annotation:

````java
@Recycle
@Builder
public Doo(String foo) {
  this.foo = foo;
}
````

`@Recycle` will have no effect if the `Doo` class has any type parameters.
Please note, the code generated by `@Recycle` uses `ThreadLocal`.

### Access level

By default, the generated static methods `fooBuilder` and `fooUpdater` are public.
This can be changed to package visibility by adding an `@AccessLevel` annotation.

````java
@AccessLevel(Access.PACKAGE)
@Builder
public Doo(String foo) {
  this.foo = foo;
}
````

### <a name="auto-value"></a>auto-value

It is allowed for the projection methods (getters) to be `abstract`.
This means that not only `@Builder` but also `@Updater` can be used on auto-value's common factory methods:

````java
import com.google.auto.value.AutoValue;
import net.zerobuilder.Builder;
import net.zerobuilder.Updater;

@AutoValue
abstract class Animal {

  @Builder
  @Updater
  static Animal create(String name, int numberOfLegs) {
    return new AutoValue_Animal(name, numberOfLegs);
  }

  abstract String name();
  abstract int numberOfLegs();
}
````

This will ensure that the generated `AnimalBuilders` class has both an `animalBuilder` and `animalUpdater` method.
The following convenience methods could then also be added to `Animals`:

````java
static AnimalBuilders.AnimalBuilder.Name builder() {
  return AnimalBuilders.animalBuilder();
}

AnimalBuilders.AnimalUpdater updater() {
  return AnimalBuilders.animalUpdater(this);
}
````
