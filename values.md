# zerobuilder for value types

### Motivation

Immutable types, also known as values, are increasingly used in place of traditional java beans.
Their constructors often have lots of arguments. This can lead to code that's hard to read.

Using the standard builder pattern may improve readability, but there are downsides:

* Creating the builder class is tedious, and the code has to be kept in sync.
* The builder pattern makes it possible to "forget" a constructor argument.
  Extending the argument list of a constructor should cause compile errors elsewhere.

Zerobuilder takes care of the boilerplate by generating two different variants of the builder pattern:

* A `Builder` that fails at compile time if constructor arguments are missing.
* A traditional-style `Updater` to make and modify shallow copies.

[1]: http://blog.crisp.se/2013/10/09/perlundholm/another-builder-pattern-for-java

### Builder

Start by adding the `@Builder` annotation to a constructor:

````java
final class Message {

  final String sender;
  final String body;
  final String recipient;

  @Builder
  Message(String sender, String body, String recipient) {
    this.sender = sender;
    this.body = body;
    this.recipient = recipient;
  }
}

````

The following class will be generated:

````java
@Generated final class MessageBuilders {

  static MessageBuilder.Sender messageBuilder() { ... }

  static final class MessageBuilder {
    interface Sender { Body sender(String sender); }
    interface Body { Recipient body(String body); }
    interface Recipient { Message recipient(String recipient); }
  }
}
````

The `messageBuilder` method returns `MessageBuilder.Sender`, the first step of a linear
chain towards the constructor goal:

![steps](https://raw.githubusercontent.com/h908714124/zerobuilder/68729a2ecdd44a60be40498eef1abc3b378fb524/dot/graph.png "steps diagram")

### Changing step order

By default, these steps are in the original order of the goal arguments.
If for some reason you would like to call them in a different order, you can use the `@Step` annotation:

````java
  @Builder
  Message(@Step(1) String sender,
          @Step(2) String body,
          @Step(0) String recipient) {
    this.sender = sender;
    this.body = body;
    this.recipient = recipient;
  }

````

### Updater

This time, we use a different annotation on the constructor:

````java
final class Message {

  final String sender;
  final String body;
  final String recipient;

  @Updater
  Message(String sender, String body, String recipient) {
    this.sender = sender;
    this.body = body;
    this.recipient = recipient;
  }
}

````

In order for the `@Updater` annotation to work,
there has to exist one corresponding _projection_
for each goal parameter.
This is the case in `Message.java`.

The following class will be generated:

````java
@Generated final class MessageBuilders {

  static MessageUpdater messageUpdater(Message message) { ... }

  static final class MessageUpdater {
    MessageUpdater sender(String sender) { ... }
    MessageUpdater body(String body) { ... }
    MessageUpdater recipient(String recipient) { ... }
    Message done() { ... }
  }
}
````

### What's a projection?

This can either be a non-private field or a non-private, non-static method,
with <em>name</em> and <em>type</em> matching one of the goal parameters. 

For example, any of the following would be a valid projection for a constructor parameter `String sender`:

1. A non-private, non-static field `String sender`
2. A non-private, non-static method `String sender()`
3. A non-private, non-static method `String getSender()`

A projection method may be `abstract`, or inherited from a parent class.

### Recycling

The builder pattern can be made more efficient by adding a `@Recycle` annotation:

````java
@Recycle
@Builder
public Doo(String foo) {
  this.foo = foo;
}
````

The `@Recycle` annotation is not allowed and will raise a compile error,
if `Doo` has any type parameters (such as `Doo<E>`.).

Please note, the code generated by `@Recycle` uses `ThreadLocal`, which can cause
memory leaks [under certain conditions](https://stackoverflow.com/questions/17968803/threadlocal-memory-leak).


### Access level

By default, the generated static methods `fooBuilder` and `fooUpdater` are public.
This can be changed to package visibility by adding an `@AccessLevel` annotation.

````java
@AccessLevel(Access.PACKAGE)
@Builder
public Doo(String foo) {
  this.foo = foo;
}
````

### <a name="auto-value"></a>auto-value

It is allowed for the projection methods (getters) to be `abstract`.
This means that not only `@Builder` but also `@Updater` can be used on auto-value's common factory methods:

````java
import com.google.auto.value.AutoValue;
import net.zerobuilder.Builder;
import net.zerobuilder.Updater;

@AutoValue
abstract class Animal {

  @Builder
  @Updater
  static Animal create(String name, int numberOfLegs) {
    return new AutoValue_Animal(name, numberOfLegs);
  }

  abstract String name();
  abstract int numberOfLegs();
}
````

This will ensure that the generated `AnimalBuilders` class has both an `animalBuilder` and `animalUpdater` method.
The following convenience methods could then also be added to `Animal`:

````java
static AnimalBuilders.AnimalBuilder.Name builder() {
  return AnimalBuilders.animalBuilder();
}

AnimalBuilders.AnimalUpdater updater() {
  return AnimalBuilders.animalUpdater(this);
}
````
