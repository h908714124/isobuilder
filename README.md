# Build anything, fast

## Motivation

The builder pattern improves readability, by making parameter names visible.

In many implementations of the builder pattern, 
such as those generated by [auto-value](https://github.com/google/auto/tree/master/value),
it is possible to specify a parameter twice, or forget a required parameter.

To guard against this, one could write a chain of interfaces, each representing one parameter.
This repetitive work is best left to a code generator.

Under the hood, a single mutable object can implement all of these &quot;step&quot; interfaces. 
Because parameters cannot be forgotten anymore, it is even safe to reuse this object and store it in a `ThreadLocal`.

### A closer look

A "Builders" class is generated by adding a `@Builders` annotation and one or more `@Goal` annotations.
Like [this](../master/examples/basic/src/main/java/net/zerobuilder/examples/basic/Message.java):

````java
@Builders(recycle = true)
final class Message {

  final String sender;
  final String body;
  final String recipient;
  final String subject;

  @Goal(toBuilder = true)
  Message(String sender, String body, String recipient, String subject) {
    this.sender = sender;
    this.body = body;
    this.recipient = recipient;
    this.subject = subject;
  }
}

````

This class is valid input for the annotation processor:

* The `recycle = true` says that builder instances should be stored in a `ThreadLocal` and reused. 
  If `ThreadLocal` fields are permissible in your project, this option may be used to reduce overhead.
* In order for `toBuilder = true` to make sense, there has to exist one corresponding "getter" or instance field, for each parameter.
  This is the case in `Message.java`.

The following structure will be generated (some implementation details left out):

````java
@Generated final class MessageBuilders {

  static MessageBuilder.Contract.Sender messageBuilder();
  static MessageBuilder.Contract.MessageUpdater messageToBuilder(Message message);

  static final class MessageBuilder {
    static final class Contract {
      interface MessageUpdater {
        Message build();
        MessageUpdater sender(String sender);
        MessageUpdater body(String body);
        MessageUpdater recipient(String recipient);
        MessageUpdater subject(String subject);
      }
      interface Sender {
        Body sender(String sender);
      }
      interface Body {
        Recipient body(String body);
      }
      interface Recipient {
        Subject recipient(String recipient);
      }
      interface Subject {
        Message subject(String subject);
      }
    }
  }
}
````

If you clone this project and do a `mvn install`, you will find the complete source code of `MessageBuilders.java`
in the `examples/basic/target/generated-sources/annotations` folder.

Let's take a closer look at the generated code:

* The `messageBuilder` and `messageToBuilder` methods return different things.
* There is a `MessageUpdater` interface, which looks like the familiar builder pattern.
  Each method can be called `0..n` times, and there is an extra `build()` method that returns `Message`.
* For each of the four goal parameters, there is one corresponding "step" interface: `Sender`, `Body`, `Recipient` and `Subject`.
* Each step interface has a single method.
  None of these methods returns the same step. It is a linear chain that leads to the goal type `Message`.

### Factory methods

In addition to constructors, the `@Goal` annotation can appear on methods, even non-static ones. 
Have a look at the [MessageFactory](../master/examples/basic/src/main/java/net/zerobuilder/examples/basic/MessageFactory.java) example,
to see what this can be used for.

### Other frameworks

Zerobuilder is flexible enough to build the classes that are generated by other frameworks:

* [auto-value](https://github.com/google/auto/tree/master/value), 
  see [Bob.java](../master/examples/autovalue/src/main/java/net/zerobuilder/examples/autovalue/Bob.java) 
* [derive4j](https://github.com/derive4j/derive4j),
  see [Request.java](../master/examples/derive4j/src/main/java/net/zerobuilder/examples/derive4j/Request.java)
* legacy [JavaBeans](https://en.wikipedia.org/wiki/JavaBean),
  such as generated by [Apache CXF](https://cxf.apache.org/cxf-xjc-plugin.html)

### A note about JavaBeans

Putting the `@Goal` annotation on a 
[field](../master/examples/basic/src/main/java/net/zerobuilder/examples/basic/Beans.java) or on a 
[type](../master/examples/basic/src/main/java/net/zerobuilder/examples/basic/Bean.java) will create "wrapping" 
builders for standard JavaBeans.

The ancient JavaBeans standard cannot be avoided in certain environments, due to framework restrictions. 
For example, [JAXB](https://jaxb.java.net/) requires the bean standard.

By wrapping the beans, zerobuilder makes the following tasks easier:

* To create new beans, by ensuring that each setter is invoked exactly once.
* To "update" beans as if they were immutable, by making shallow copies via `toBuilder`.

### Use it in your project

This is a standard Java 7 annotation processor. No compiler plugin or special IDE is needed. 
However, maven compiler plugin version `3.5.1` or greater is recommended.

Your IDE may need some initial help, to recognize that `target/generated-sources/annotations` 
now contains generated sources.

To consumers of your project, the annotated classes, as well as the generated code, 
will appear as normal classes.
The annotations `@Builders`, `@Goal` and possibly `@Step` will never be present in your `.class` files,
so no transitive dependency on zerobuilder arises.

The maven coordinates:

````xml
<dependency>
    <groupId>com.github.h908714124</groupId>
    <artifactId>zerobuilder</artifactId>
    <version>1.101</version>
    <scope>provided</scope>
</dependency>
````
